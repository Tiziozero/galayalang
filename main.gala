let i: i32;
let j: i32 = 2 + 4;
let m: i32 = 3;

// @t <term> -> let <term> = fn_call()

fn bz(k: u32) -> u32 {
    return k - 1, k + 1;
}


fn fn_(a: u32, len: usize) {

}

fn main() -> i32 {
    let a: i32 = 1 + -*!1;
    let b: u32 = 0;
    a = b = j = m;
    a = -3;
    main(b, b, 1+-3);
    if a < 0 { fn_(a); }
    else if a > 0 { fn_(b); }
    else { fn_(fn_(a+b)); }

    if a return a; else return b;
    if !b return a;

    if a == -3 {
        return main(a,a,b);
    } else {
        fn_(&a);
    }
    bz(b,b,a); // can't be a name
    let k: u32[3] = fn_(a, b, 1+-3);
    let c: u32 = *fn_();
    let h: u32* = &c;
    return 0-1;
    return (a+b)*(3 +m - 2*j);
}
